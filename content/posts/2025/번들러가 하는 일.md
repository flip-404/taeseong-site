---
title: '웹사이트가 뜨기까지, 번들러는 무슨 일을 할까?'
description: '우리가 브라우저에서 웹사이트를 보기까지, 그 뒤에는 번들러라는 조용한 조력자가 있다. 여러 개의 파일을 하나로 묶고, 필요한 코드만 남기며, 최적화까지 담당하는 번들러의 역할을 알기 쉽게 풀어본다.'
tags: ['Webpack', 'Vite', 'Babel', 'SWC']
date: '2025-06-27'
---

# 번들링과 번들러 완전정복 가이드

## 번들링이 뭔가요?
> 여러 개의 파일들을 하나로 합쳐주는 과정

요즘 웹 개발할 때 코드를 여러 개 파일로 나눠서 작업하잖아요? 각 파일마다 자기 할 일이 있고, 서로 연결되어서 하나의 앱을 만들어내죠. 근데 이걸 다 따로따로 불러오면... 진짜 느려터져요. 번들링이 바로 이런 골치 아픈 문제를 해결해주는 구세주 같은 존재입니다.

## 번들링이 왜 필요한지 알아보자

### HTTP 요청이 비싼 이유
파일 하나하나 개별로 가져오는 건 정말 비효율적이에요. 왜 그런지 한번 보시죠.

브라우저가 파일 하나 달라고 할 때마다 이런 일들이 벌어져요
- DNS 조회로 도메인을 IP 주소로 바꾸기
- TCP 3-way handshake로 연결 맺기
- HTTP 요청 보내기
- 서버 응답 기다리고 받기

이런 게 쌓이고 쌓이면... 으악 😱

### 헤더 오버헤드가 진짜 문제
실제로 계산해보면 깜짝 놀라요.

500바이트짜리 작은 파일 200개를 로드한다고 해보죠

**파일 하나씩 로드할 때:**
- HTTP 헤더: 요청/응답당 대략 250바이트 → 200개 × 500바이트 = 100KB
- TCP/IP 헤더: 패킷당 40바이트 → 200개 × 40바이트 = 8KB
- 헤더만으로 108KB!
- 네트워크 지연(요청당 60ms): 200개 × 60ms = 12초 😭

**번들링 후:**
- 100KB 파일 1개만 로드
- HTTP 헤더 오버헤드: 500바이트
- TCP/IP 헤더 (약 70개 패킷): 2.8KB
- 헤더 총합: 3.3KB
- 네트워크 지연: 60ms

결과? 헤더 오버헤드 97% 감소, 로딩 시간 200배 빨라짐! 🚀

### 브라우저가 한 번에 못 가져와요
HTTP/1.1에서는 같은 도메인에 동시 연결이 보통 6개로 제한돼요. 200개 파일을 6개씩 나눠서 가져와야 하니까... 더 오래 걸리죠.

HTTP/2에서는 멀티플렉싱이 가능하지만, 그래도 동시 스트림 수 제한(보통 100개)이 있고, 서버도 힘들어해요.

## 번들러가 해주는 일들

### 1. 의존성 관리
번들러는 모듈들이 어떻게 연결되어 있는지 파악해서 올바른 순서로 합쳐줘요.

예를 들어 이런 파일들이 있다면

```javascript
// app.js
import { calculator } from './math.js';
import { logger } from './utils.js';

const result = calculator.add(5, 3);
logger.info(`결과: ${result}`);
```

```javascript
// math.js
import { validator } from './utils.js';

export const calculator = {
  add: (a, b) => {
    if (validator.isNumber(a, b)) {
      return a + b;
    }
    throw new Error('숫자만 넣어주세요!');
  }
};
```

```javascript
// utils.js
export const logger = {
  info: (message) => console.log(`[INFO] ${message}`)
};

export const validator = {
  isNumber: (...args) => args.every(arg => typeof arg === 'number')
};
```

번들러가 이걸 분석해서 의존성 그래프를 만들어요

```
app.js → math.js → utils.js
app.js → utils.js
```

그래서 utils.js → math.js → app.js 순서로 번들링해줍니다

```javascript
// 번들링 결과
const logger = {
  info: (message) => console.log(`[INFO] ${message}`)
};

const validator = {
  isNumber: (...args) => args.every(arg => typeof arg === 'number')
};

const calculator = {
  add: (a, b) => {
    if (validator.isNumber(a, b)) {
      return a + b;
    }
    throw new Error('숫자만 넣어주세요!');
  }
};

const result = calculator.add(5, 3);
logger.info(`결과: ${result}`);
```

### 2. 코드 압축과 최적화

**압축(Minification & Uglification)**
불필요한 공백, 주석 다 없애고 변수명도 짧게 바꿔줘요:

```javascript
// 압축 전
function calculateTotalPrice(itemPrice, taxRate, discountAmount) {
  // 세금 계산
  const tax = itemPrice * taxRate;
  // 최종 가격 계산
  const finalPrice = itemPrice + tax - discountAmount;
  return finalPrice;
}

// 압축 후
function a(b,c,d){const e=b*c;return b+e-d}
```

**트리 셰이킹(Tree Shaking)**
안 쓰는 코드는 과감하게 버려버려요:

```javascript
// helpers.js
export function formatDate(date) {
  return date.toISOString().split('T')[0];
}

export function formatCurrency(amount) {
  return `₩${amount.toLocaleString()}`;
}

export function formatPercent(value) {  // 이거 안 써요
  return `${(value * 100).toFixed(2)}%`;
}

// main.js
import { formatDate, formatCurrency } from './helpers.js';

console.log(formatDate(new Date()));
console.log(formatCurrency(10000));
```

트리 셰이킹 후에는 `formatPercent` 함수가 번들에서 쏙 빠져요.

**트리 셰이킹이 되려면?**
ES6 모듈(ESM)에서만 가능해요. CommonJS에서는 안 되는데, 이유가 있어요

1. **동적이라서**: CommonJS는 런타임에 모듈이 결정돼요
```javascript
// 실행할 때까지 뭘 로드할지 몰라요
const moduleName = someCondition ? './moduleA.js' : './moduleB.js';
const module = require(moduleName);  // 빌드할 때 예측 불가
```

2. **수정 가능해서**: exports 객체를 런타임에 바꿀 수 있어요
```javascript
const utils = require('./utils.js');
if (needsExtraFeature) {
  utils.extraFunction = () => console.log('추가 기능');  // 동적 수정
}
```

반면 ESM은 정적이고 불변이에요

```javascript
// 정적으로 딱 결정됨
import { specificFunction } from './module.js';

// 불변성 - 수정 불가
specificFunction = () => {}; // ❌ TypeError 발생
```

### 3. 코드 스플리팅
번들 파일이 너무 크면 처음 로딩이 느려져요. 필요한 것만 먼저 로드하고, 나머지는 필요할 때 가져오면 되죠.

```javascript
// React에서 코드 스플리팅
import React, { Suspense } from 'react';

const LazyDashboard = React.lazy(() => import('./Dashboard'));
const LazySettings = React.lazy(() => import('./Settings'));

function App() {
  return (
    <Suspense fallback={<div>로딩 중...</div>}>
      <Route path="/dashboard" component={LazyDashboard} />
      <Route path="/settings" component={LazySettings} />
    </Suspense>
  );
}
```

동적 import도 써볼 수 있어요:

```javascript
async function loadFeature() {
  const { heavyCalculation } = await import('./heavyFeature.js');
  return heavyCalculation();
}

// 버튼 클릭할 때만 로드
button.addEventListener('click', async () => {
  const result = await loadFeature();
  console.log(result);
});
```

### 4. 모듈 시스템 변환
서로 다른 모듈 시스템 간의 변환도 해줘요.

**ESM → CommonJS 변환:**
```javascript
// ESM 원본
export function greet(name) {
  return `안녕하세요, ${name}님!`;
}

export default function farewell(name) {
  return `안녕히 가세요, ${name}님!`;
}

// CommonJS 변환 결과
function greet(name) {
  return `안녕하세요, ${name}님!`;
}

function farewell(name) {
  return `안녕히 가세요, ${name}님!`;
}

exports.greet = greet;
module.exports = farewell;
module.exports.greet = greet;
```

### 5. 에셋 관리
JavaScript 말고도 CSS, 이미지, 폰트 등등 다 처리해줘요

```javascript
// 이미지 import
import logoImage from './assets/logo.png';
import './styles/main.css';

// 번들러가 처리한 후
const logoImage = '/assets/logo.abc123.png';  // 해시 추가해줌
// CSS는 별도 파일로 빼거나 인라인으로 넣어줌
```

### 6. 트랜스파일링
최신 JavaScript 문법을 구형 브라우저에서도 돌아가게 바꿔줘요.

```javascript
// ES6+ 원본
const users = [
  { name: '김철수', age: 25 },
  { name: '이영희', age: 30 },
  { name: '박민수', age: 28 }
];

const adultUsers = users
  .filter(user => user.age >= 18)
  .map(user => ({ ...user, isAdult: true }));

const greetUser = (name = '손님') => `안녕하세요, ${name}님!`;

// ES5 변환 결과
var users = [
  { name: '김철수', age: 25 },
  { name: '이영희', age: 30 },
  { name: '박민수', age: 28 }
];

var adultUsers = users
  .filter(function(user) { return user.age >= 18; })
  .map(function(user) { 
    return Object.assign({}, user, { isAdult: true }); 
  });

var greetUser = function(name) {
  if (name === undefined) name = '손님';
  return '안녕하세요, ' + name + '님!';
};
```

**요즘 핫한 도구들**
- **Babel**: 전통적인 JavaScript 컴파일러 (믿을 만함)
- **SWC**: Rust로 만든 엄청 빠른 트랜스파일러 (Next.js 12+에서 기본 사용)
- **esbuild**: Go로 만든 초고속 번들러 (정말 빨라요!)

### 7. 소스맵 생성
번들링된 코드에서 에러가 나면, 원본 코드 어디서 문제가 생겼는지 알려주는 매핑 파일을 만들어줘요.

```javascript
// 원본 코드 (main.js:15)
function calculateDiscount(price, rate) {
  return price * rate / 100;  // 여기서 에러 발생
}

// 번들링된 코드에서는 위치가 달라져도
// 소스맵 덕분에 원본 파일의 정확한 위치를 알 수 있어요
```

## 실제 있었던 일: 성능 개선 스토리

예전에 어떤 쇼핑몰에서 실제로 있었던 일이에요. 모바일 유저들이 구형 폰을 많이 쓰고 있었는데, 어느 날 갑자기 구매 버튼이 먹통이 된 거예요.
원인을 찾아보니까 개발자가 화살표 함수를 썼는데, 구형 브라우저에서 지원 안 됐던 거였어요

```javascript
// 문제 코드
const handlePurchase = () => {
  // 구매 로직
};

// 구형 브라우저용 수정
var handlePurchase = function() {
  // 구매 로직
};
```

Babel 같은 트랜스파일러만 썼어도 이런 문제는 없었을 텐데... 아쉬웠죠.

## 정리하자면

번들러는 요즘 웹 개발에서 정말 필수에요. 뭘 해주는지 정리하면

1. **의존성 관리**: 모듈들 관계 파악해서 올바른 순서로 합치기
2. **성능 최적화**: 압축, 트리 셰이킹으로 파일 크기 줄이기
3. **코드 스플리팅**: 필요한 것만 먼저 로드해서 빠르게 만들기
4. **호환성 확보**: 트랜스파일링으로 구형 브라우저 지원
5. **개발 편의성**: 소스맵으로 디버깅 쉽게 만들기


Create React App이나 Create Next App 같은 도구들이 이런 복잡한 설정을 다 자동으로 해주긴 하지만, 번들러가 어떻게 동작하는지 알면 더 효율적인 웹앱을 만들 수 있어요.
특히 큰 프로젝트에서는 번들링 전략이 성능에 직접적으로 영향을 주니까, 각 도구의 특성 잘 파악해서 프로젝트에 딱 맞는 설정을 찾는 게 중요해요